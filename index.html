<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Målvaktsstatistik</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }
  </style>
</head>
<body class="bg-gray-50">
  <div class="mx-auto max-w-screen-sm p-3 sm:p-4">
    <div class="sticky top-0 z-10 -mx-3 -mt-3 mb-3 bg-white/80 backdrop-blur p-3 border-b">
      <h1 class="text-xl font-bold">Målvaktsstatistik</h1>
    </div>
    <a id="btn-compare"
      class="px-3 py-1 rounded-xl border text-sm hover:bg-gray-50">
      Jämför målvakter
    </a>


    <!-- Auth -->
    <div id="auth" class="rounded-2xl border bg-white p-4 shadow-sm">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold">Logga in</h2>
        <button id="btn-signout" class="text-sm underline hidden">Logga ut</button>
      </div>
      <div id="auth-forms">
        <div class="grid gap-2 sm:grid-cols-2">
          <input id="email" type="email" placeholder="E-post" class="rounded-xl border p-2">
          <input id="password" type="password" placeholder="Lösenord" class="rounded-xl border p-2">
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <button id="btn-signin" class="rounded-xl border py-2">Logga in</button>
          <button id="btn-signup" class="rounded-xl border py-2">Skapa konto</button>
        </div>
        <div id="auth-msg" class="text-sm text-red-600 mt-2"></div>
      </div>
      <div id="whoami" class="text-sm text-gray-600 mt-2 hidden"></div>
    </div>

    <!-- Teamkontroll -->
    <div id="team-bar" class="hidden rounded-2xl border bg-white p-3 shadow-sm mb-4">
      <div class="flex flex-col sm:flex-row gap-2 sm:items-center sm:justify-between">
        <div class="flex items-center gap-2">
          <span class="text-sm text-gray-600">Team:</span>
          <select id="team-select" class="rounded-xl border p-2 text-sm"></select>
          <button id="btn-new-team" class="rounded-xl border px-3 py-2 text-sm">Nytt team</button>
        </div>
        <div class="flex items-center gap-2">
          <input id="invite-email" type="email" placeholder="epost@exempel.se" class="rounded-xl border p-2 text-sm">
          <button id="btn-invite" class="rounded-xl border px-3 py-2 text-sm">Bjud in</button>
        </div>
      </div>
      <div id="team-msg" class="text-xs text-red-600 mt-2"></div>
      <div id="invites-panel" class="text-sm text-gray-700 mt-2 hidden"></div>
    </div>

    <!-- App UI -->
    <div id="app" class="hidden">
      <!-- Snabb inmatning -->
      <div class="rounded-2xl border shadow-sm p-3 mb-4 bg-white">
        <div class="flex gap-2">
          <div class="flex-1">
            <label class="text-xs text-gray-500">Datum</label>
            <input id="f-date" type="date" class="w-full rounded-xl border p-2">
          </div>
          <div class="flex-1">
            <label class="text-xs text-gray-500">Motstånd</label>
            <input id="f-opp" type="text" placeholder="t.ex. Kumla" class="w-full rounded-xl border p-2">
          </div>
        </div>

        <div class="mt-2">
          <label class="text-xs text-gray-500">Resultat</label>
          <div class="grid grid-cols-3 gap-2 mt-1">
            <button data-res="V" class="resbtn rounded-xl border py-2 text-sm">Vinst</button>
            <button data-res="O" class="resbtn rounded-xl border py-2 text-sm">Oavgjort</button>
            <button data-res="F" class="resbtn rounded-xl border py-2 text-sm">Förlust</button>
          </div>
        </div>
        
        <div class="mt-2">
          <label class="text-xs text-gray-500">Kommentar</label>
          <textarea id="f-notes" rows="2" placeholder="t.ex. bra tredje period, PP 2 mål..." class="w-full rounded-xl border p-2"></textarea>
        </div>

        <div class="mt-3">
          <div class="flex items-center justify-between mb-1">
            <label class="text-xs text-gray-500">Målvakter (min / räddningar / skott)</label>
            <div class="flex gap-2">
              <button id="btn-add-goalie" class="text-xs underline">Lägg till målvakt</button>
              <button id="reset-entries" class="text-xs underline">Nollställ</button>
            </div>
          </div>
          <div id="goalie-grid" class="space-y-2"></div>
        </div>

        <button id="add-match" class="mt-3 w-full rounded-2xl bg-black text-white py-3 font-medium">Lägg till match</button>
        <div id="app-msg" class="text-sm text-red-600 mt-2"></div>
      </div>

      <!-- Översikt -->
      <div id="cards" class="grid sm:grid-cols-2 gap-3 mb-4"></div>
      <!-- Graf: Rädd% över tid -->
        <div class="rounded-2xl border shadow-sm p-3 mb-4 bg-white">
          <div class="flex items-center justify-between">
            <div class="text-sm text-gray-500">Rädd% över tid</div>
            <div class="flex items-center gap-2">
              <label class="text-xs text-gray-500">Målvakt</label>
              <select id="chart-goalie" class="rounded-xl border p-2 text-sm"></select>
            </div>
          </div>
          <div class="mt-3">
            <canvas id="svpctChart" height="120"></canvas>
            <div id="chart-empty" class="text-center text-sm text-gray-500 mt-2 hidden">
              Ingen data att visa ännu.
            </div>
          </div>
        </div>
      <!-- Resultat-summering -->
      <div class="rounded-2xl border shadow-sm p-3 mb-4 bg-white">
        <div class="text-sm text-gray-500">Resultat</div>
        <div class="grid grid-cols-3 gap-2 mt-2 text-center">
          <div class="rounded-xl border p-2"><div class="text-xs text-gray-500">Vinst</div><div id="stat-v" class="text-lg font-semibold">0</div></div>
          <div class="rounded-xl border p-2"><div class="text-xs text-gray-500">Oavgjort</div><div id="stat-o" class="text-lg font-semibold">0</div></div>
          <div class="rounded-xl border p-2"><div class="text-xs text-gray-500">Förlust</div><div id="stat-f" class="text-lg font-semibold">0</div></div>
        </div>
        <div class="text-xs text-gray-500 mt-2">Tot. minuter (alla målvakter): <span id="stat-min" class="font-medium text-gray-700">0</span></div>
      </div>

      <!-- Export / Import -->
      <div class="rounded-2xl border shadow-sm p-3 mb-4 bg-white">
        <div class="text-sm text-gray-500 mb-2">Exportera / Importera</div>
        <div class="grid grid-cols-2 sm:grid-cols-4 gap-2">
          <button id="btn-exp-json" class="rounded-xl border py-2">Export JSON</button>
          <button id="btn-exp-csv"  class="rounded-xl border py-2">Export CSV</button>
          <label class="rounded-xl border py-2 text-center cursor-pointer">
            <input id="imp-json" type="file" accept=".json" class="hidden">Import JSON
          </label>
          <label class="rounded-xl border py-2 text-center cursor-pointer">
            <input id="imp-csv"  type="file" accept=".csv"  class="hidden">Import CSV
          </label>
        </div>
        <div class="text-xs text-gray-500 mt-2">
          JSON innehåller målvakter + matcher. CSV är semikolon-separerad (;). Import gör upsert (datum+motstånd) och ersätter stats för matchen.
        </div>
      </div>

      <!-- Modal: Lägg skott i aktuell match -->
    <div id="shot-modal" class="fixed inset-0 hidden items-center justify-center bg-black/40 z-50">
      <div class="bg-white rounded-2xl p-4 w-full max-w-md">
        <div class="flex items-center justify-between mb-2">
          <div class="font-semibold">Lägg skott – <span id="shot-modal-code"></span></div>
          <button type="button" class="text-sm underline" onclick="closeShotModal()">Stäng</button>
        </div>

        <div class="text-xs text-gray-500 mb-1">Klicka på rinken för att lägga skott</div>
        <div id="shot-rink" class="relative w-full border rounded-xl overflow-hidden" style="aspect-ratio: 200/85; cursor: crosshair;">
          <svg viewBox="0 0 200 85" class="absolute inset-0 w-full h-full pointer-events-none">
            <rect x="0" y="0" width="200" height="85" rx="10" ry="10" fill="#f8fafc" stroke="#e5e7eb"/>
            <line x1="100" y1="0" x2="100" y2="85" stroke="#e11d48" stroke-width="0.8"/>
            <rect x="0" y="30" width="5" height="25" fill="#fee2e2"/>
            <rect x="195" y="30" width="5" height="25" fill="#fee2e2"/>
          </svg>
          <!-- klick-markers -->
          <div id="shot-dots" class="absolute inset-0"></div>
        </div>

        <div class="grid grid-cols-3 gap-2 mt-3">
          <label class="text-sm">Period
            <select id="shot-period" class="w-full border rounded-xl p-2">
              <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
            </select>
          </label>
          <label class="text-sm col-span-2">Tid (mm:ss)
            <input id="shot-time" class="w-full border rounded-xl p-2" placeholder="00:00" value="00:00">
          </label>
          <label class="text-sm col-span-3">Resultat
            <select id="shot-result" class="w-full border rounded-xl p-2">
              <option value="save">Räddning</option>
              <option value="goal">Mål</option>
              <option value="miss">Utanför</option>
              <option value="block">Blockerat</option>
            </select>
          </label>
        </div>

        <div class="flex items-center justify-between mt-3">
          <div class="text-xs text-gray-500">
            <button type="button" class="underline" onclick="undoLastShot()">Ångra senaste</button>
            · <button type="button" class="underline" onclick="clearShotsForCurrent()">Rensa alla</button>
          </div>
          <button type="button" class="rounded-xl border px-3 py-1" onclick="closeShotModal()">Klar</button>
        </div>
      </div>
    </div>


      <!-- Matcher -->
      <div id="match-list" class="space-y-3 mb-24"></div>
    </div>
  </div>

  <script>
    // ===== Supabase-konfig: BYT DESSA =====
    const SUPABASE_URL  = "https://okdvcvbmgposbhvrygop.supabase.co";   // <-- byt
    const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9rZHZjdmJtZ3Bvc2JodnJ5Z29wIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2ODgyMjUsImV4cCI6MjA3MzI2NDIyNX0.w4SCljFULEduafWZexzmQqyG08pGoUFOeSCbfuCFaJg";                  // <-- byt
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
    const normCode = (c) => String(c || '').trim().toUpperCase();


    // ===== Helpers =====
    const $ = (s) => document.querySelector(s);
    const today = () => new Date().toISOString().slice(0,10);
    const num = (v) => { const n = Number(String(v ?? '').replace(',', '.')); return Number.isFinite(n) ? n : 0; };
    const sum = (a) => a.reduce((x,y)=>x+(Number.isFinite(y)?y:0),0);
    const pct = (saves, shots) => shots>0 ? ((saves/shots)*100).toFixed(2)+'%' : '–';
  
    // ===== Skott-buffert för pågående match =====
// Struktur: { CODE: [ {x,y,period,time_sec,result} , ... ], ... }
const SHOTS_BUFFER = {};
let CURRENT_SHOT_CODE = null;

function mmssToSec(s){
  const m = String(s||'').trim().split(':');
  if (m.length !== 2) return 0;
  const mm = parseInt(m[0],10), ss = parseInt(m[1],10);
  return (Number.isFinite(mm)?mm:0)*60 + (Number.isFinite(ss)?ss:0);
}

function updateShotBadge(code){
  const el = document.getElementById(`shot-count-${code}`);
  if (!el) return;
  const n = (SHOTS_BUFFER[code] || []).length;
  el.textContent = `${n} skott`;
}

function openShotModal(code){
  CURRENT_SHOT_CODE = code;
  document.getElementById('shot-modal-code').textContent = code;
  document.getElementById('shot-modal').classList.remove('hidden');
  document.getElementById('shot-modal').classList.add('flex');
  // rensa och rita existerande punkter
  renderShotDots();
}

function closeShotModal(){
  document.getElementById('shot-modal').classList.add('hidden');
  document.getElementById('shot-modal').classList.remove('flex');
  CURRENT_SHOT_CODE = null;
}

function renderShotDots(){
  const dots = document.getElementById('shot-dots');
  dots.innerHTML = '';
  const arr = SHOTS_BUFFER[CURRENT_SHOT_CODE] || [];
  const wrap = document.getElementById('shot-rink');
  const r = wrap.getBoundingClientRect();
  arr.forEach(s => {
    const d = document.createElement('div');
    d.className = 'absolute rounded-full';
    d.style.width = '10px'; d.style.height = '10px';
    d.style.left = `${Math.round(s.x * r.width) - 5}px`;
    d.style.top  = `${Math.round(s.y * r.height) - 5}px`;
    d.style.background = s.result === 'goal' ? '#ef4444' : '#1f2937'; // röd för mål, mörkgrå för övrigt
    dots.appendChild(d);
  });
}

document.getElementById('shot-rink').addEventListener('click', (ev) => {
  if (!CURRENT_SHOT_CODE) return;
  const wrap = ev.currentTarget;
  const rect = wrap.getBoundingClientRect();
  const x = (ev.clientX - rect.left) / rect.width;
  const y = (ev.clientY - rect.top)  / rect.height;
  const period  = parseInt(document.getElementById('shot-period').value, 10) || 1;
  const timeSec = mmssToSec(document.getElementById('shot-time').value || '00:00');
  const result  = document.getElementById('shot-result').value || 'save';

  SHOTS_BUFFER[CURRENT_SHOT_CODE] ||= [];
  SHOTS_BUFFER[CURRENT_SHOT_CODE].push({ x, y, period, time_sec: timeSec, result });

  updateShotBadge(CURRENT_SHOT_CODE);
  renderShotDots();
});

function undoLastShot(){
  if (!CURRENT_SHOT_CODE) return;
  const arr = SHOTS_BUFFER[CURRENT_SHOT_CODE] || [];
  arr.pop();
  updateShotBadge(CURRENT_SHOT_CODE);
  renderShotDots();
}

function clearShotsForCurrent(){
  if (!CURRENT_SHOT_CODE) return;
  SHOTS_BUFFER[CURRENT_SHOT_CODE] = [];
  updateShotBadge(CURRENT_SHOT_CODE);
  renderShotDots();
}

// ===== Spara skott till DB efter att matchen skapats =====

// Shots-events per match & målvakt: { save, goal, miss, block, sog, total }
async function dbGroupShotStatsByMatch(matches){
  if (!matches?.length) return new Map();
  const matchIds = matches.map(m => m.id);

  const { data, error } = await sb
    .from('shots')
    .select('match_id, goalie_id, result')
    .eq('team_id', CURRENT_TEAM_ID)
    .in('match_id', matchIds);

  if (error) { showError('load-shots-per-match', error); return new Map(); }

  const byMatch = new Map();
  for (const r of (data || [])) {
    const m = byMatch.get(r.match_id) || new Map();
    const cur = m.get(r.goalie_id) || { save:0, goal:0, miss:0, block:0, sog:0, total:0 };
    const key = String(r.result || '').toLowerCase();
    if (key in cur) cur[key] += 1;
    else cur[key] = (cur[key] || 0) + 1;
    cur.sog   = (cur.save || 0) + (cur.goal || 0);
    cur.total = cur.sog + (cur.miss || 0) + (cur.block || 0);
    m.set(r.goalie_id, cur);
    byMatch.set(r.match_id, m);
  }
  return byMatch;
}

// Manuella stats per match & målvakt: { minutes, saves, shots }
async function dbLoadManualStatsByMatch(matches){
  if (!matches?.length) return new Map();
  const matchIds = matches.map(m => m.id);

  const { data, error } = await sb
    .from('match_goalie_stats')
    .select('match_id, goalie_id, minutes, saves, shots')
    .eq('team_id', CURRENT_TEAM_ID)
    .in('match_id', matchIds);

  if (error) { showError('load-manual-stats', error); return new Map(); }

  const byMatch = new Map();
  for (const r of (data || [])) {
    const m = byMatch.get(r.match_id) || new Map();
    m.set(r.goalie_id, {
      minutes: r.minutes|0,
      saves:   r.saves|0,
      shots:   r.shots|0
    });
    byMatch.set(r.match_id, m);
  }
  return byMatch;
}

// (valfritt alias om du har kvar gamla anrop)
const dbGroupShotsByMatch = dbGroupShotStatsByMatch;


async function dbDeleteMatch(matchId){
  if (!matchId) throw new Error('matchId saknas');
  if (!CURRENT_TEAM_ID) throw new Error('CURRENT_TEAM_ID saknas');

  // shots har FK on delete cascade (om du satt så i DB); annars rensas de av RLS-policy separat.
  const { error } = await sb
    .from('matches')
    .delete()
    .eq('id', matchId)
    .eq('team_id', CURRENT_TEAM_ID);  // extra skydd

  if (error) throw error;
  const msg = 'Match borttagen.';
  const box = document.getElementById('app-msg');
  if (box) box.textContent = msg;
}

async function dbInsertShots(matchId){
  if (!CURRENT_TEAM_ID) throw new Error('Saknar CURRENT_TEAM_ID vid skottinsert');
  if (!matchId) throw new Error('Saknar matchId vid skottinsert');

  // bygg goalie-id lookup
  const { data: gData, error: gErr } = await sb
    .from('goalies').select('id,code').eq('team_id', CURRENT_TEAM_ID);
  if (gErr) throw gErr;

  const idByCode = Object.fromEntries((gData||[]).map(g => [String(g.code).trim().toUpperCase(), g.id]));

  // konvertera buffert till rader
  const rows = [];
  for (const [codeRaw, shots] of Object.entries(SHOTS_BUFFER)){
    const code = String(codeRaw).trim().toUpperCase();
    const gid = idByCode[code];
    if (!gid) {
      console.warn('[dbInsertShots] Okänd målvaktkod i detta team:', code);
      continue;
    }
    (shots||[]).forEach(s => {
      rows.push({
        team_id:  CURRENT_TEAM_ID,
        match_id: matchId,
        goalie_id: gid,
        x: s.x, y: s.y,
        period: s.period || 1,
        time_sec: s.time_sec || 0,
        result: s.result || 'save'
      });
    });
  }

  // Inget att spara? Säg det högt i UI så vi vet.
  if (!rows.length){
    const box = document.getElementById('app-msg');
    if (box) box.textContent = '[shots] Inga buffrade skott att spara.';
    console.info('[dbInsertShots] 0 rader (tom buffert).');
    return 0;
  }

  console.table(rows.map(r => ({
    match_id: r.match_id,
    goalie_id: r.goalie_id,
    x: +r.x?.toFixed?.(3),
    y: +r.y?.toFixed?.(3),
    period: r.period,
    time_sec: r.time_sec,
    result: r.result
  })));

  // Sätt .select('id') för att få tillbaka antal insatta rader
  const { data: insData, error: insErr } = await sb
    .from('shots')
    .insert(rows)
    .select('id');

  if (insErr) {
    // Visa RLS-/policyfel tydligt
    showError('insert-shots', insErr);
    throw insErr;
  }

  const inserted = (insData || []).length;
  const msg = `[shots] Sparade ${inserted}/${rows.length} skott till matchen.`;
  console.info(msg);
  const box = document.getElementById('app-msg');
  if (box) box.textContent = msg;

  // töm bufferten efter lyckad insert
  for (const k of Object.keys(SHOTS_BUFFER)) SHOTS_BUFFER[k] = [];
  // uppdatera badges i UI
  (GOALIES||[]).forEach(g => updateShotBadge(g.code));

  return inserted;
}



    function showError(where, err){
      console.error(where, err);
      const msg = (err && (err.message || err.details || err.hint)) || String(err);
      const box = $('#app-msg') || $('#auth-msg') || $('#team-msg');
      if (box) box.textContent = `[${where}] ${msg}`;
    }

    async function getSessionSafe(timeoutMs = 2000){
      const timeout = new Promise((_, rej) => setTimeout(()=>rej(new Error('getSession timeout')), timeoutMs));
      try {
        const res = await Promise.race([sb.auth.getSession(), timeout]);
        if (res?.data?.session) return res.data.session;
      } catch {}
      const userRes = await sb.auth.getUser();
      if (userRes?.data?.user){
        const s = await sb.auth.getSession();
        return s?.data?.session ?? null;
      }
      return null;
    }

    // ===== Auth UI =====
    const whoami = $('#whoami');
    const authForms = $('#auth-forms');
    const btnSignOut = $('#btn-signout');

    $('#btn-signup').addEventListener('click', async () => {
      $('#auth-msg').textContent = '';
      try {
        const { error } = await sb.auth.signUp({ email: $('#email').value.trim(), password: $('#password').value });
        if (error) throw error;
        $('#auth-msg').textContent = 'Konto skapat. Logga in om du inte redan är inloggad.';
      } catch (e) { showError('signup', e); }
    });

    $('#btn-signin').addEventListener('click', async () => {
      $('#auth-msg').textContent = '';
      try {
        const { error } = await sb.auth.signInWithPassword({ email: $('#email').value.trim(), password: $('#password').value });
        if (error) throw error;
      } catch (e) { showError('signin', e); }
    });

    btnSignOut.addEventListener('click', async () => { await sb.auth.signOut(); });

    let CURRENT_UID = null;
    let CURRENT_TEAM_ID = null;

    async function boot(){
      try {
        const session = await getSessionSafe();
        if (session?.user?.id){
          CURRENT_UID = session.user.id;
          whoami.textContent = `Inloggad som ${session.user.email}`;
          whoami.classList.remove('hidden');
          btnSignOut.classList.remove('hidden');
          authForms.classList.add('hidden');
          $('#app').classList.remove('hidden');
          $('#team-bar').classList.remove('hidden');

          await initTeams();  // team först
          await initApp();    // sedan ladda UI-data
        } else {
          CURRENT_UID = null;
          CURRENT_TEAM_ID = null;
          whoami.classList.add('hidden');
          btnSignOut.classList.add('hidden');
          authForms.classList.remove('hidden');
          $('#app').classList.add('hidden');
          $('#team-bar').classList.add('hidden');
        }
      } catch (e){ showError('boot', e); }
    }

    sb.auth.onAuthStateChange((_ev, session) => {
      CURRENT_UID = session?.user?.id || null;
      boot();
    });
    boot();

    // ===== Team-API =====
    async function dbMyTeams(){
      const { data, error } = await sb
        .from('team_members')
        .select('team_id, role, teams:team_id ( id, name, owner_id )')
        .order('created_at', { ascending: true });
      if (error) throw error;
      return (data||[]).map(r => ({ id: r.teams.id, name: r.teams.name, role: r.role, owner_id: r.teams.owner_id }));
    }

    async function dbCreateTeam(name){
        const { data: t, error: te } = await sb
            .from('teams')
            .insert([{ name, owner_id: CURRENT_UID }])   // viktigt
            .select('id, name, owner_id')
            .single();
        if (te) throw te;

        const { data:{ user } } = await sb.auth.getUser();
        const { error: me } = await sb
            .from('team_members')
            .insert([{ team_id: t.id, user_id: user.id, role: 'owner' }]);
        if (me && me.code !== '23505') throw me;

        return t;
    }


    async function dbInvite(email, team_id){
      const { data, error } = await sb.from('team_invites').insert([{ team_id, email }]).select('id, email, status, created_at').single();
      if (error) throw error;
      return data;
    }

    async function dbMyInvites(){
      const { data, error } = await sb
        .from('team_invites')
        .select('id, team_id, email, status, created_at, teams:team_id (name)')
        .eq('status','pending')
        .order('created_at',{ascending:false});
      if (error) throw error;
      return data || [];
    }

    async function dbAcceptInvite(invite_id){
      const { data: inv, error: e1 } = await sb.from('team_invites').select('id, team_id, email, status').eq('id', invite_id).single();
      if (e1) throw e1;
      const { data:{ user } } = await sb.auth.getUser();
      const { error: e2 } = await sb.from('team_members').insert([{ team_id: inv.team_id, user_id: user.id, role: 'member' }]);
      if (e2 && e2.code !== '23505') throw e2;
      const { error: e3 } = await sb.from('team_invites').update({ status:'accepted' }).eq('id', invite_id);
      if (e3) throw e3;
      return true;
    }

    async function initTeams(){
      const bar = $('#team-bar');
      const sel = $('#team-select');
      const msg = $('#team-msg');
      bar.classList.add('hidden'); msg.textContent='';

      let teams = await dbMyTeams();
      // ta bort ev. dubbletter från äldre data
      teams = teams.filter((t, i, arr) => arr.findIndex(x => x.id === t.id) === i);

      if (!teams.length){
        const t = await dbCreateTeam('Mitt Team');
        teams = await dbMyTeams();
      }

      if (!CURRENT_TEAM_ID) CURRENT_TEAM_ID = teams[0].id;

      sel.innerHTML = '';
      teams.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t.id;
        opt.textContent = `${t.name}${t.role==='owner'?' (ägare)':''}`;
        if (t.id === CURRENT_TEAM_ID) opt.selected = true;
        sel.appendChild(opt);
      });

      sel.onchange = async () => {
        CURRENT_TEAM_ID = sel.value;
        try { await refreshAll(); } catch(e){ showError('team-switch', e); }
      };

      $('#btn-new-team').onclick = async () => {
        const name = prompt('Teamnamn:')?.trim();
        if (!name) return;
        try {
          const t = await dbCreateTeam(name);
          CURRENT_TEAM_ID = t.id;
          await initTeams();
          await refreshAll();
        } catch(e){ showError('new-team', e); }
      };

      $('#btn-invite').onclick = async () => {
        msg.textContent='';
        const email = $('#invite-email').value.trim();
        if (!email) return;
        try {
          await dbInvite(email, CURRENT_TEAM_ID);
          msg.textContent = `Inbjudan skickad till ${email}. Be personen logga in här – de ser och kan acceptera inbjudan.`;
          $('#invite-email').value='';
        } catch(e){ showError('invite', e); }
      };

      const panel = $('#invites-panel');
      const invites = await dbMyInvites();
      if (invites.length){
        panel.classList.remove('hidden');
        panel.innerHTML = invites.map(i => `
          <div class="flex items-center justify-between py-1">
            <div>Inbjuden till <b>${i.teams?.name || 'Team'}</b> (${i.email})</div>
            <button data-acc="${i.id}" class="rounded-xl border px-3 py-1 text-sm">Acceptera</button>
          </div>
        `).join('');
        panel.querySelectorAll('button[data-acc]').forEach(btn => {
          btn.onclick = async () => {
            try {
              await dbAcceptInvite(btn.dataset.acc);
              panel.innerHTML = 'Inbjudan accepterad.';
              await initTeams();
              await refreshAll();
            } catch(e){ showError('accept-invite', e); }
          };
        });
      } else { panel.classList.add('hidden'); panel.innerHTML=''; }

      bar.classList.remove('hidden');
    }

    // ===== DB-funktioner (team-baserade) =====
  
    // Seedar standardmålvakter per team – idempotent
    async function dbEnsureDefaultGoalies(){
      // vilka koder finns redan för aktuellt team?
        const { data, error } = await sb
            .from('goalies')
            .select('code')
            .eq('team_id', CURRENT_TEAM_ID);
        if (error) throw error;

        const have = new Set((data || []).map(g => normCode(g.code)));
        const wanted = [
            { code:'LL', name:'Leo L' },
            { code:'IE', name:'Isac E' },
            { code:'EH', name:'Emil H' },
            { code:'LK', name:'Leo K' },
        ];

        const missing = wanted
            .map(g => ({ code: normCode(g.code), name: g.name }))
            .filter(g => !have.has(g.code))
            .map(g => ({ ...g, team_id: CURRENT_TEAM_ID }));

        if (missing.length){
            // unik-regel är (team_id, code) → upsert tål dubbletter
            const { error: insErr } = await sb
            .from('goalies')
            .upsert(missing, { onConflict: 'team_id,code', ignoreDuplicates: true });
            if (insErr) throw insErr;
        }
    }



    async function dbLoadGoalies(){
        const { data, error } = await sb.from('goalies')
            .select('id,code,name')
            .eq('team_id', CURRENT_TEAM_ID)
            .order('code');
        if (error) throw error;
        return (data || []).map(g => ({ ...g, code: normCode(g.code) })); // <- normalisera
    }


    async function dbAddGoalie(code, name){
        const CODE = normCode(code);
        const up = await sb.from('goalies')
            .upsert({ team_id: CURRENT_TEAM_ID, code: CODE, name },
                    { onConflict: 'team_id,code', ignoreDuplicates: true })
            .select('id')
            .maybeSingle();

        if (up.error && up.error.code !== '23505') throw up.error;
        if (up.data?.id) return up.data.id;

        const ex = await sb.from('goalies')
            .select('id')
            .eq('team_id', CURRENT_TEAM_ID)
            .eq('code', CODE)
            .single();
        if (ex.error) throw ex.error;
        return ex.data.id;
    }




    async function dbAddMatch({ date, opponent, result, notes, entries }) {
        // Skapa match
        const { data: mData, error: mErr } = await sb
            .from('matches')
            .insert([{ team_id: CURRENT_TEAM_ID, date, opponent, result, notes }])
            .select('id')
            .single();
        if (mErr) throw mErr;
        const matchId = mData.id;

        // Endast rader med data
        const filled = (entries || [])
            .map(e => ({ ...e, code: normCode(e.code) }))
            .filter(e => (e.minutes|0) + (e.saves|0) + (e.shots|0) > 0);

        if (!filled.length) {
          await dbInsertShots(matchId)
          return matchId;
        }  

        // Läs aktuella målvakter → idByCode
        const readMap = async () => {
            const { data: gData, error } = await sb.from('goalies')
            .select('id, code')
            .eq('team_id', CURRENT_TEAM_ID);
            if (error) throw error;
            return Object.fromEntries((gData || []).map(g => [normCode(g.code), g.id]));
        };
        let idByCode = await readMap();

        // Skapa ev. saknade målvakter baserat på UI-listan (namn hämtas från GOALIES)
        const nameByCode = Object.fromEntries((GOALIES || [])
            .map(g => [normCode(g.code), g.name]));

        const missing = [...new Set(filled
            .filter(e => !idByCode[e.code])
            .map(e => e.code))];

        for (const code of missing){
            const name = nameByCode[code] || code;
            await dbAddGoalie(code, name); // idempotent
        }

        // Läs om mappningen (nu ska alla koder ha id)
        idByCode = await readMap();

        const rows = filled.map(e => {
            const gid = idByCode[e.code];
            if (!gid) throw new Error(`Okänd målvaktkod: ${e.code} (finns inte i teamet)`);
            return {
            team_id:  CURRENT_TEAM_ID,
            match_id: matchId,
            goalie_id: gid,
            minutes:  e.minutes|0,
            saves:    e.saves|0,
            shots:    e.shots|0,
            };
        });

        const { error: sErr } = await sb.from('match_goalie_stats').insert(rows);
        await dbInsertShots(matchId);
        if (sErr) throw sErr;
        return matchId;
    }





    async function dbListMatches(){
      const { data, error } = await sb
        .from('matches')
        .select(`
          id, date, opponent, result, notes,
          match_goalie_stats (
            minutes, saves, shots, goalie_id,
            goalies:goalie_id ( code, name )
          )
        `)
        .eq('team_id', CURRENT_TEAM_ID)
        .order('date',{ascending:false});
      if (error) throw error;

      return (data||[]).map(m => ({
        id: m.id,
        date: m.date,
        opponent: m.opponent,
        result: m.result,
        notes: m.notes,
        entries: (m.match_goalie_stats||[]).map(e => ({
          code: e.goalies.code,
          name: e.goalies.name,
          minutes: e.minutes,
          saves: e.saves,
          shots: e.shots
        }))
      }));
    }

    async function dbDeleteMatch(matchId){
      const { error } = await sb.from('matches').delete().eq('id', matchId).eq('team_id', CURRENT_TEAM_ID);
      if (error) throw error;
    }

    // ===== Export / Import =====
    function download(filename, content, mime){
      const blob = new Blob([content], { type: (mime || 'text/plain') + ';charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }

    async function exportJSON(){
      const goalies = await dbLoadGoalies();
      const matches = await dbListMatches();
      const payload = { exported_at: new Date().toISOString(), team_id: CURRENT_TEAM_ID, goalies, matches };
      download('mv_export.json', JSON.stringify(payload, null, 2), 'application/json');
    }

    function escCSV(v){ const s = String(v ?? ''); return /[;"\n]/.test(s) ? '"' + s.replaceAll('"','""') + '"' : s; }
    function buildCSV(goalies, matches){
      const head = ['date','opponent','result',
        ...goalies.flatMap(g => [`${g.code}_minutes`, `${g.code}_saves`, `${g.code}_shots`]),
        'notes'
      ];
      const lines = [head.join(';')];

      for (const m of matches){
        const map = Object.fromEntries((m.entries || []).map(e => [e.code, e]));
        const cols = [
          `"${m.date}"`,                           // behåll datum som text i Excel
          escCSV(m.opponent || ''),                // säkra semikolon/citat-tecken
          m.result,
          ...goalies.flatMap(g => {
            const e = map[g.code] || {};
            return [e.minutes ?? '', e.saves ?? '', e.shots ?? ''];
          }),
          escCSV(m.notes || '')
        ];
        lines.push(cols.join(';'));
    }
  // CRLF för Excel
  return lines.join('\r\n');
}


    async function exportCSV(){
      const goalies = await dbLoadGoalies();
      const matches = await dbListMatches();
      const csv = buildCSV(goalies, matches);

      const BOM = '\uFEFF'; // UTF-8 BOM → rätt å/ä/ö i Excel
      download('mv_export.csv', BOM + csv, 'text/csv');
    }


    function bindExportButtons(){
      const j = $('#btn-exp-json'), c = $('#btn-exp-csv');
      if (j && !j._bound){ j.addEventListener('click', ()=>exportJSON().catch(e=>showError('export-json', e))); j._bound=true; }
      if (c && !c._bound){ c.addEventListener('click', ()=>exportCSV().catch(e=>showError('export-csv', e)));   c._bound=true; }
    }

    // ---- Import helpers (goalies map + upsert match) ----
    async function dbGetGoalieMapEnsure(codesAndNames){
        const { data: gData, error } = await sb.from('goalies').select('id,code,name').eq('team_id', CURRENT_TEAM_ID);
        if (error) throw error;
        const have = new Map((gData || []).map(g => [normCode(g.code), g]));
        const missing = (codesAndNames || [])
            .map(x => ({ code: normCode(x.code), name: x.name }))
            .filter(x => x.code && !have.has(x.code));

        if (missing.length){
            const rows = missing.map(x => ({ team_id: CURRENT_TEAM_ID, code: x.code, name: x.name || x.code }));
            const { data: ins, error: e2 } = await sb.from('goalies').insert(rows).select('id,code,name');
            if (e2) throw e2;
            (ins || []).forEach(g => have.set(normCode(g.code), g));
        }
        return Object.fromEntries([...have.entries()].map(([code,g]) => [code, g.id]));
    }

    function dbGroupShotStatsByMatch(matches){
      if (!matches?.length) return new Map();

      const matchIds = matches.map(m => m.id);
      return sb
        .from('shots')
        .select('match_id, goalie_id, result')
        .eq('team_id', CURRENT_TEAM_ID)
        .in('match_id', matchIds)
        .then(({ data, error }) => {
          if (error) { showError('load-shots-per-match', error); return new Map(); }

          // Map: matchId -> Map(goalie_id -> { save, goal, miss, block, sog, total })
          const byMatch = new Map();
          for (const row of (data || [])) {
            const m = byMatch.get(row.match_id) || new Map();
            const cur = m.get(row.goalie_id) || { save:0, goal:0, miss:0, block:0, sog:0, total:0 };

            const key = String(row.result || '').toLowerCase();
            if (key in cur) cur[key] += 1; else cur[key] = (cur[key] || 0) + 1;

            cur.sog = (cur.save || 0) + (cur.goal || 0);
            cur.total = cur.sog + (cur.miss || 0) + (cur.block || 0);

            m.set(row.goalie_id, cur);
            byMatch.set(row.match_id, m);
          }
          return byMatch;
        });
    }

    // Backwards-compat alias:
    const dbGroupShotsByMatch = dbGroupShotStatsByMatch;

    async function dbFindOrCreateMatchByKey({ date, opponent, result, notes }){
      let { data: found, error: sErr } = await sb
        .from('matches')
        .select('id')
        .eq('team_id', CURRENT_TEAM_ID)
        .eq('date', date)
        .eq('opponent', opponent || '')
        .limit(1)
        .maybeSingle();
      if (sErr && sErr.code !== 'PGRST116') throw sErr;
      if (found?.id){
        await sb.from('matches').update({ result, notes }).eq('id', found.id);
        return found.id;
      }
      const { data: ins, error } = await sb
        .from('matches')
        .insert([{ team_id: CURRENT_TEAM_ID, date, opponent: opponent||'', result, notes }])
        .select('id')
        .single();
      if (error) throw error;
      return ins.id;
    }

    // ---- Import JSON ----
    async function importJSONFile(file){
      const text = await file.text();
      const obj = JSON.parse(text);
      const goalies = obj.goalies || [];
      const matches = obj.matches || [];

      const idByCode = await dbGetGoalieMapEnsure(goalies.map(g => ({code:g.code, name:g.name})));

      for (const m of matches){
        const matchId = await dbFindOrCreateMatchByKey({
          date: m.date,
          opponent: m.opponent || '',
          result: m.result || 'V',
          notes: m.notes || ''
        });
        await sb.from('match_goalie_stats').delete().eq('match_id', matchId);
        const rows = (m.entries||[]).map(e => ({
          team_id: CURRENT_TEAM_ID,
          match_id: matchId,
          goalie_id: idByCode[e.code],
          minutes: e.minutes|0,
          saves:   e.saves|0,
          shots:   e.shots|0
        }));
        if (rows.length){
          const { error } = await sb.from('match_goalie_stats').insert(rows);
          if (error) throw error;
        }
      }
    }

    // ---- Import CSV ----
    function parseCSVLine(line){
      const out=[]; let cur=''; let inQ=false;
      for (let i=0;i<line.length;i++){
        const ch=line[i];
        if (inQ){
          if (ch === '"'){ if (line[i+1] === '"'){ cur+='"'; i++; } else { inQ=false; } }
          else cur += ch;
        } else {
          if (ch === '"') inQ=true;
          else if (ch === ';'){ out.push(cur); cur=''; }
          else cur += ch;
        }
      }
      out.push(cur); return out;
    }

    async function importCSVFile(file){
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(Boolean);
      if (lines.length < 2) throw new Error('CSV saknar data.');
      const header = lines[0].split(';').map(h=>h.trim());
      const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
      const codes = [];
      for (const h of header){
        const m = h.match(/^([A-Za-z0-9]+)_(minutes|saves|shots)$/);
        if (m && !codes.includes(m[1])) codes.push(m[1]);
      }
      const idByCode = await dbGetGoalieMapEnsure(codes.map(code => ({code, name: code})));

      for (let li=1; li<lines.length; li++){
        const cols = parseCSVLine(lines[li]);
        const date = cols[idx['date']] || today();
        const opponent = cols[idx['opponent']] || '';
        const result = cols[idx['result']] || 'V';
        const notes  = cols[idx['notes']] || '';

        const matchId = await dbFindOrCreateMatchByKey({ date, opponent, result, notes });

        const rows = codes.map(code => ({
          team_id: CURRENT_TEAM_ID,
          match_id: matchId,
          goalie_id: idByCode[code],
          minutes: Number(cols[idx[`${code}_minutes`]]||0)||0,
          saves:   Number(cols[idx[`${code}_saves`]]||0)||0,
          shots:   Number(cols[idx[`${code}_shots`]]||0)||0
        }));
        await sb.from('match_goalie_stats').delete().eq('match_id', matchId);
        const { error } = await sb.from('match_goalie_stats').insert(rows);
        if (error) throw error;
      }
    }

    // ===== App state & UI =====
    let GOALIES = [];
    let formResult = 'V';

    async function initApp(){
      $('#f-date').value = today();

      document.querySelectorAll('.resbtn').forEach(btn => {
        btn.classList.remove('border-black');
        if (btn.dataset.res === 'V') btn.classList.add('border-black');
        btn.onclick = () => {
          formResult = btn.dataset.res;
          document.querySelectorAll('.resbtn').forEach(b => b.classList.remove('border-black'));
          btn.classList.add('border-black');
        };
      });

      try {
        await dbEnsureDefaultGoalies();
        GOALIES = await dbLoadGoalies();
        renderGoalieInputs();
        await refreshAll();
      } catch (e){ showError('initApp', e); }

      $('#reset-entries').onclick = () => {
        GOALIES.forEach(g => {
          $('#m-'+g.code).value='0';
          $('#s-'+g.code).value='0';
          $('#t-'+g.code).value='0';
        });
      };

      $('#btn-add-goalie').onclick = async () => {
        const code = normCode(prompt('Kod (t.ex. LL):') || '');
        const name = (prompt('Namn (t.ex. Leo L):') || '').trim();
        if (!code || !name) return;
        try {
            await dbAddGoalie(code, name);
            GOALIES = await dbLoadGoalies();
            renderGoalieInputs();
        } catch (e) { showError('add-goalie', e); }
      };


      $('#add-match').onclick = async () => {
        $('#app-msg').textContent = '';
        const entries = GOALIES.map(g => ({
          code: g.code,
          minutes: num($('#m-'+g.code).value),
          saves:   num($('#s-'+g.code).value),
          shots:   num($('#t-'+g.code).value),
        }));
        try {
          await dbAddMatch({
            date: $('#f-date').value || today(),
            opponent: $('#f-opp').value || '',
            result: formResult,
            notes: $('#f-notes').value || '',
            entries
          });
          document.querySelectorAll('#goalie-grid input').forEach(i => i.value='0');
          $('#f-opp').value=''; $('#f-notes').value='';
          await refreshAll();
        } catch (e){ showError('add-match', e); }
      };

      // Export/Import-bindningar
      bindExportButtons();
      const impJ = $('#imp-json');
      const impC = $('#imp-csv');
      if (impJ && !impJ._bound){
        impJ.addEventListener('change', async (e)=>{
          $('#app-msg').textContent='';
          try {
            const f = e.target.files?.[0]; if (!f) return;
            await importJSONFile(f);
            await refreshAll();
          } catch (err){ showError('import-json', err); }
          finally { e.target.value=''; }
        });
        impJ._bound=true;
      }
      if (impC && !impC._bound){
        impC.addEventListener('change', async (e)=>{
          $('#app-msg').textContent='';
          try {
            const f = e.target.files?.[0]; if (!f) return;
            await importCSVFile(f);
            await refreshAll();
          } catch (err){ showError('import-csv', err); }
          finally { e.target.value=''; }
        });
        impC._bound=true;
      }
    }

    function renderGoalieInputs(){
      const grid = $('#goalie-grid');
      grid.innerHTML = '';
      GOALIES.forEach(g => {
        const row = document.createElement('div');
        row.className = 'grid grid-cols-12 items-center gap-2';
        row.innerHTML = `
          <div class="col-span-4">
            <div class="font-medium text-sm">${g.name}</div>
            <div class="text-xs text-gray-500">${g.code}</div>
          </div>
          <input id="m-${g.code}" inputmode="numeric" class="col-span-2 rounded-xl border p-2 text-center" placeholder="min" value="0" />
          <input id="s-${g.code}" inputmode="numeric" class="col-span-3 rounded-xl border p-2 text-center" placeholder="räddn" value="0" />
          <input id="t-${g.code}" inputmode="numeric" class="col-span-3 rounded-xl border p-2 text-center" placeholder="skott" value="0" />
          <span class="inline-flex items-center gap-1 text-xs">
            <span id="shot-count-${g.code}" class="rounded-lg border px-2 py-0.5">0 skott</span>
            <button type="button" id="btn-shot-${g.code}" class="rounded-lg border px-2 py-0.5">+ Skott</button>
          </span>
    `;
    grid.appendChild(row);

    // Se till att vi har en buffert-array för denna målvakt
    SHOTS_BUFFER[g.code] ||= [];

    // Koppla knappen till rätt målvakt
    const btn = row.querySelector(`#btn-shot-${g.code}`);
    btn.addEventListener('click', () => openShotModal(g.code));

    // Uppdatera badge om det finns buffrade skott
    updateShotBadge(g.code);
  });
}


    // ===== Graf: Rädd% över tid (Chart.js) =====
    let svpctChart = null;

    function pctNum(saves, shots){
      return shots > 0 ? +(((saves / shots) * 100).toFixed(2)) : null;
    }

    // 3-matchers glidande medel (valfritt fönster)
    function movingAvg(arr, window=3){
      const out = [];
      for (let i=0;i<arr.length;i++){
        const slice = arr.slice(Math.max(0, i-window+1), i+1).filter(v => v != null);
        out.push(slice.length ? +(slice.reduce((a,b)=>a+b,0)/slice.length).toFixed(2) : null);
      }
      return out;
    }

    function updateChartSelect(){
      const sel = document.getElementById('chart-goalie');
      if (!sel) return;
      const current = sel.value;
      sel.innerHTML = '';
      (GOALIES || []).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g.code; opt.textContent = `${g.name} (${g.code})`;
        sel.appendChild(opt);
      });
      // behåll tidigare val om möjligt, annars välj första
      if (current && [...sel.options].some(o => o.value === current)) sel.value = current;
      else if (GOALIES?.[0]) sel.value = GOALIES[0].code;
    }

    function renderSavePctChart(matches){
      const sel = document.getElementById('chart-goalie');
      const canvas = document.getElementById('svpctChart');
      const msg = document.getElementById('chart-empty');
      if (!sel || !canvas) return;

      const code = (sel.value || (GOALIES?.[0]?.code) || '').toUpperCase();
      const sorted = [...(matches || [])].sort((a,b)=>a.date.localeCompare(b.date));
      const labels = [];
      const values = [];

      sorted.forEach(m => {
        const e = (m.entries || []).find(x => (x.code || '').toUpperCase() === code);
        if (e && (e.saves != null) && (e.shots != null)){
          labels.push(m.date);
          values.push(pctNum(e.saves, e.shots)); // kan bli null vid 0 skott
        }
      });

      const hasData = values.some(v => v != null);
      msg?.classList.toggle('hidden', hasData);

      if (svpctChart){ svpctChart.destroy(); svpctChart = null; }
      if (!hasData) return;

      const ma = movingAvg(values, 3);

      svpctChart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: `Rädd% (${code})`, data: values, spanGaps: true, tension: 0.3, pointRadius: 3 },
            { label: '3-matchers snitt', data: ma, spanGaps: true, borderDash: [6,4], tension: 0.3, pointRadius: 0 }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { suggestedMin: 60, suggestedMax: 100, ticks: { callback: v => v + '%' } },
            x: { ticks: { autoSkip: true, maxRotation: 0 } }
          },
          plugins: {
            legend: { position: 'bottom' },
            tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y?.toFixed?.(2) ?? '–'}%` } }
          }
        }
      });
    }

    // redraw när man byter målvakt
    document.addEventListener('change', (e)=>{
      if (e.target && e.target.id === 'chart-goalie'){
        renderSavePctChart(window.__LATEST_MATCHES__ || []);
      }
    });


    async function refreshAll(){
        try {
            await dbEnsureDefaultGoalies();
            GOALIES = await dbLoadGoalies();
            renderGoalieInputs();

            const matches = await dbListMatches();

            const [shotStatsByMatch, manualStatsByMatch] = await Promise.all([
            dbGroupShotStatsByMatch(matches),
            dbLoadManualStatsByMatch(matches)
            ]);

            renderCards(matches);
            renderResultSummary(matches);
            renderMatchList(matches, { shotStatsByMatch, manualStatsByMatch }); // <—

            window.__LATEST_MATCHES__ = matches;
            updateChartSelect();
            renderSavePctChart(matches);

            const btnCompare = document.getElementById('btn-compare');
            if (btnCompare && CURRENT_TEAM_ID) {
            btnCompare.href = `compare.html?team=${encodeURIComponent(CURRENT_TEAM_ID)}`;
            btnCompare.target = '_self';
            }
        } catch (e){ showError('refresh-all', e); }
    }

    function renderMatchList(matches, maps = {}){
        const { shotStatsByMatch = new Map(), manualStatsByMatch = new Map() } = maps;
        const wrap = document.getElementById('match-list');
        wrap.innerHTML = '';

        const goalieById = new Map((GOALIES || []).map(g => [g.id, g]));

        for (const m of matches){
            const card = document.createElement('div');
            card.className = 'rounded-2xl border p-4 mb-4';

            const hdr = `
            <div class="flex items-center justify-between mb-2">
                <div>
                <div class="text-sm text-gray-500">${m.date} • ${m.result || ''}</div>
                <div class="font-medium">${m.opponent || 'Motstånd saknas'}</div>
                </div>
                <a href="#" data-del="${m.id}" class="text-sm underline">Ta bort</a>
            </div>
            `;

            const sMap = shotStatsByMatch.get(m.id)  || new Map(); // events
            const gMap = manualStatsByMatch.get(m.id) || new Map(); // manuellt

            // union av alla målvakts-id som finns i antingen events eller manuellt
            const unionIds = new Set([...sMap.keys(), ...gMap.keys()]);

            let rowsHtml = '';
            if (unionIds.size){
            for (const gid of unionIds){
                const g  = goalieById.get(gid) || {};
                const ev = sMap.get(gid) || null;
                const ms = gMap.get(gid) || null;

                const minutes = ms?.minutes ?? '–';

                // välj Källa för Räddn/Skott:
                // 1) Finns events? använd dem
                // 2) annars manuella stats (shots/saves)
                let saves, goals, sog;
                if (ev){
                saves = ev.save || 0;
                goals = ev.goal || 0;
                sog   = ev.sog  || (saves + goals);
                } else {
                const mSaves = ms?.saves | 0;
                const mShots = ms?.shots | 0;
                saves = mSaves;
                goals = Math.max(0, mShots - mSaves);
                sog   = Math.max(0, mShots);
                }

                const name = g.name || 'Okänd målvakt';
                const code = g.code || '';

                rowsHtml += `
                <div class="grid grid-cols-12 text-sm py-1">
                    <div class="col-span-6">${name} <span class="text-gray-500">(${code})</span></div>
                    <div class="col-span-2 text-center">${minutes}</div>
                    <div class="col-span-2 text-center">${saves}</div>
                    <div class="col-span-2 text-center font-medium">
                    ${sog}${goals ? `<span class="ml-1 text-xs text-red-600">(${goals} mål)</span>` : ''}
                    </div>
                </div>
                `;
            }
            } else {
            rowsHtml = `<div class="text-sm text-gray-500">Inga skott registrerade.</div>`;
            }

            card.innerHTML = hdr + `
            <div class="grid grid-cols-12 text-xs text-gray-500 border-b pb-1 mb-1">
                <div class="col-span-6">Målvakt</div>
                <div class="col-span-2 text-center">Min</div>
                <div class="col-span-2 text-center">Räddn</div>
                <div class="col-span-2 text-center">Skott</div>
            </div>
            ${rowsHtml}
            <div class="mt-2 text-[11px] text-gray-500">“Skott” = räddningar + mål. Miss/block visas inte här.</div>
            `;

            wrap.appendChild(card);
        }

        // — event delegation för Ta bort (om du inte redan har)
        if (!wrap.__hasDeleteHandler__) {
            wrap.addEventListener('click', async (e) => {
            const a = e.target.closest('[data-del]');
            if (!a) return;
            e.preventDefault();
            const matchId = a.dataset.del;
            if (!matchId) return;
            if (!confirm('Ta bort matchen? Detta tar även bort skott kopplade till matchen.')) return;
            try { await dbDeleteMatch(matchId); await refreshAll(); }
            catch (err) { showError('delete-match', err); }
            });
            wrap.__hasDeleteHandler__ = true;
        }
    }




    function renderCards(matches){
      const wrap = $('#cards'); 
      wrap.innerHTML='';
      GOALIES.forEach(g => {
        const all = matches.flatMap(m => m.entries.filter(e => e.code === g.code));
        const minutes = sum(all.map(e => e.minutes));
        const saves   = sum(all.map(e => e.saves));
        const shots   = sum(all.map(e => e.shots));
        const card = document.createElement('div');
        card.className = 'rounded-2xl border shadow-sm p-3 bg-white';
        card.innerHTML = `
          <div class="flex items-center justify-between">
            <div>
              <div class="text-sm text-gray-500">Målvakt</div>
              <div class="text-lg font-semibold">${g.name} <span class="text-sm text-gray-500">(${g.code})</span></div>
            </div>
            <div class="text-right">
              <div class="text-sm text-gray-500">Rädd%</div>
              <div class="text-xl font-bold">${pct(saves, shots)}</div>
            </div>
          </div>
          <div class="grid grid-cols-3 gap-2 mt-3 text-center text-sm">
            <div class="rounded-xl border p-2"><div class="text-xs text-gray-500">Minuter</div><div class="font-semibold">${minutes}</div></div>
            <div class="rounded-xl border p-2"><div class="text-xs text-gray-500">Räddningar</div><div class="font-semibold">${saves}</div></div>
            <div class="rounded-xl border p-2"><div class="text-xs text-gray-500">Skott</div><div class="font-semibold">${shots}</div></div>
          </div>
          <div class="mt-3 flex justify-end">
            <a href="goalie.html?team=${encodeURIComponent(CURRENT_TEAM_ID)}&code=${encodeURIComponent(g.code)}"
              class="px-3 py-1 rounded-xl border text-sm hover:bg-gray-50">
              Detaljer
            </a>
          </div>
        `;
        wrap.appendChild(card);
      });
    }

    function renderResultSummary(matches){
      const v = matches.filter(m => m.result === 'V').length;
      const o = matches.filter(m => m.result === 'O').length;
      const f = matches.filter(m => m.result === 'F').length;
      $('#stat-v').textContent = v;
      $('#stat-o').textContent = o;
      $('#stat-f').textContent = f;
      const minutesTotal = GOALIES
        .map(g => matches.flatMap(m => m.entries.filter(e => e.code===g.code)).reduce((a,e)=>a+e.minutes,0))
        .reduce((a,b)=>a+b,0);
      $('#stat-min').textContent = minutesTotal;
    }

    function renderMatchList(matches, shotStatsByMatch){
      const wrap = document.getElementById('match-list');
      wrap.innerHTML = '';

      // snabb lookup
      const goalieById = new Map((GOALIES || []).map(g => [g.id, g]));

      for (const m of matches){
        const card = document.createElement('div');
        card.className = 'rounded-2xl border p-4 mb-4';

        const hdr = `
          <div class="flex items-center justify-between mb-2">
            <div>
              <div class="text-sm text-gray-500">${m.date} • ${m.result || ''}</div>
              <div class="font-medium">${m.opponent || 'Motstånd saknas'}</div>
            </div>
            <a href="#" data-del="${m.id}" class="text-sm underline">Ta bort</a>
          </div>
        `;

        const statsMap = shotStatsByMatch?.get(m.id) || new Map();

        let rowsHtml = '';
        if (statsMap.size){
          for (const [gid, s] of statsMap.entries()){
            const g = goalieById.get(gid) || {};
            const name = g.name || 'Okänd målvakt';
            const code = g.code || '';
            const saves = s.save ?? 0;
            const goals = s.goal ?? 0;
            const sog   = s.sog  ?? (saves + goals);

            rowsHtml += `
              <div class="grid grid-cols-12 text-sm py-1">
                <div class="col-span-6">${name} <span class="text-gray-500">(${code})</span></div>
                <div class="col-span-2 text-center">–</div>
                <div class="col-span-2 text-center">${saves}</div>
                <div class="col-span-2 text-center font-medium">
                  ${sog}${goals ? `<span class="ml-1 text-xs text-red-600">(${goals} mål)</span>` : ''}
                </div>
              </div>
            `;
          }
        } else {
          rowsHtml = `<div class="text-sm text-gray-500">Inga skott registrerade.</div>`;
        }

        card.innerHTML = hdr + `
          <div class="grid grid-cols-12 text-xs text-gray-500 border-b pb-1 mb-1">
            <div class="col-span-6">Målvakt</div>
            <div class="col-span-2 text-center">Min</div>
            <div class="col-span-2 text-center">Räddn</div>
            <div class="col-span-2 text-center">Skott</div>
          </div>
          ${rowsHtml}
          <div class="mt-2 text-[11px] text-gray-500">“Skott” = räddningar + mål. Miss/block visas inte här.</div>
        `;

        wrap.appendChild(card);
        // koppla klick bara en gång
        if (!wrap.__hasDeleteHandler__) {
        wrap.addEventListener('click', async (e) => {
            const a = e.target.closest('[data-del]');
            if (!a) return;

            e.preventDefault();
            const matchId = a.dataset.del;
            if (!matchId) return;

            if (!confirm('Ta bort matchen? Detta tar även bort skott kopplade till matchen.')) return;

            try {
            await dbDeleteMatch(matchId);
            await refreshAll();
            } catch (err) {
            showError('delete-match', err);
            }
        });
        wrap.__hasDeleteHandler__ = true;
        }

      }
    }



  </script>
</body>
</html>
